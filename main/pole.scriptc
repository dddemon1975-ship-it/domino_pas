
ÿ 
¡ 
local bone_shared = require("main.bone_shared")
function video_reklama(self)
	stop_animations(self)
	set_button(self, 5)
	set_ramka(self, 1)
	
	self.f_vid_rek = true
	
	set_button(self, 2)
	set_ramka(self, 1)
	ubrat_all_bones(self)
	for i = 1, 28 do
		if self.block[i][5] ~= 0 then
			
			if self.block[i][5] == 2 then
				msg.post(self.id[i], "set_flag")
				msg.post(self.id[i], "switch_to_sprite1")
			else
				msg.post(self.id[i], "reset_flag")
				msg.post(self.id[i], "switch_to_sprite2")
			end
		end
	end
	self.animation_allowed = true
	for i = 1, 28 do
		create_bone(self, i, self.run_col[i][1], self.pole[i][3], self.pole[i][4], self.pole[i][5], self.pole[i][6])
	end
	start_animations(self)
end
function button_rundom_set(self)
	if self.f_reload > 0 then
		msg.post("button_rundom", "set_image", {image_number = self.f_reload})
	else
		if self.rek_but_rel >0 then
			msg.post("button_rundom", "set_image", {image_number = 5})
		else
			msg.post("button_rundom", "set_image", {image_number = 4})
		end
	end
end
function start_animations(self)
	self.animation_allowed = true
	self.active_timers = {} 

	for i, anim in ipairs(self.pending_animations) do
		local timer_id = timer.delay(anim.delay, false, function()
			if self.animation_allowed then
				go.animate(anim.id, "position", go.PLAYBACK_ONCE_FORWARD, 
				vmath.vector3(anim.xx, anim.yy, 0), go.EASING_OUTBOUNCE, 0.8)

				go.set_position(vmath.vector3(anim.xx, anim.yy, anim.zz), anim.id)
				msg.post(anim.id, "set_blok", {rotation = anim.tt})

				go.animate(anim.id, "euler.z", go.PLAYBACK_ONCE_FORWARD, 
				anim.tt, go.EASING_OUTBACK, 0.8)
			end
		end)
		table.insert(self.active_timers, timer_id)
	end

	self.pending_animations = {}
end


function stop_animations(self)
	self.animation_allowed = false

	
	for i = 1, 28 do
		if self.id[i] then
			go.cancel_animations(self.id[i], "position")
			go.cancel_animations(self.id[i], "euler.z")
			go.set_position(vmath.vector3(10000, 10000, 0), self.id[i])
		end
	end

	
	self.pending_animations = {}
	self.active_timers = {}
end

function create_bone(self, i, bon, xx, yy, tt, zz)
	if self.block[i][5] == 0 or not self.animation_allowed then
		return
	end

	
	msg.post(self.id[i], "set_blok", {variant = bon, rotation = -300, numb = i})
	go.set_position(vmath.vector3(0, -5000, zz), self.id[i])

	
	local animation_data = {
		id = self.id[i],
		xx = xx, yy = yy, zz = zz, tt = tt,
		delay = i * 0.05
	}

	table.insert(self.pending_animations, animation_data)
end
function create_bone_m(self, i, bon, xx, yy, tt, zz)
	if self.block[i][5] == 0 then
		return
	end

	
	msg.post(self.id[i], "set_blok", {variant = bon, rotation = tt, numb = i})
	go.set_position(vmath.vector3(xx, yy, zz), self.id[i])

	
	go.set_position(vmath.vector3(xx, yy, zz), self.id[i])
	go.set_rotation(vmath.quat_rotation_z(tt), self.id[i])
end

function resp(self)
	if self.v1 > 0 then
		msg.post(self.id[self.v1], "spin_15")
		self.v1 = 0
	end
	if self.v2 > 0 then
		msg.post(self.id[self.v2], "spin_15")
		self.v2 = 0
	end
	
end


function update_camera_to_fit_bounds(self)
	
	local min_x = -2800
	local max_x = 2800
	local min_y = -2600
	local max_y = 3200

	local width = max_x - min_x
	local height = max_y - min_y
	local w, h = window.get_size()

	local zoom = math.max(width / w, height / h) * 1.1  
	go.set("#camera", "orthographic_zoom", zoom)

	
	local center_x = (min_x + max_x) / 2
	local center_y = (min_y + max_y) / 2
	go.set("#camera", "position", vmath.vector3(center_x, center_y, 0))

	print(string.format("Camera: zoom=%.3f, center=(%.0f,%.0f)", zoom, center_x, center_y))
	return zoom
end


function on_message(self, message_id, message, sender)
	if message_id == hash("window_resized") then
		update_camera_to_fit_bounds(self)
	end
end
local function check_available_moves(self)
	local sf = 0
	for i = 1, 27 do
		if self.block[i][5] == 2 then
			local s1 = self.run_col[i][2]
			for j = i + 1, 28 do
				if self.block[j][5] == 2 and (self.run_col[j][2] + s1) == 12 then
					sf = 1
					print(self.run_col[j][2], " / ", s1)
				end
			end
		end
	end
	return sf
end
function ubrat_all_bones(self)
	for i = 1, 28 do
		if self.id[i] then
			go.set_position(vmath.vector3(10000, 10000, 0), self.id[i])
		end
	end
end


local function shuffle_until_available_moves(self, attempt)
	attempt = attempt or 1
	local max_attempts = 10

	
	if attempt == 1 then
		ubrat_all_bones(self)
		print("–ù–∞—á–∏–Ω–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏–µ...")
	end

	
	local active_indices = {}
	local active_rows = {}

	for i = 1, 28 do
		if self.block[i][5] ~= 0 then
			table.insert(active_indices, i)
			table.insert(active_rows, self.run_col[i])
		end
	end

	for i = #active_rows, 2, -1 do
		local j = math.random(1, i)
		active_rows[i], active_rows[j] = active_rows[j], active_rows[i]
	end

	for idx, original_index in ipairs(active_indices) do
		self.run_col[original_index] = active_rows[idx]
	end

	print("–ü–æ–ø—ã—Ç–∫–∞ " .. attempt .. ": –ø–µ—Ä–µ–º–µ—à–∞–Ω–æ " .. #active_rows .. " –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å—Ç—Ä–æ–∫")

	
	local temp_block_states = {}
	for i = 1, 28 do
		temp_block_states[i] = self.block[i][5]  

		
		if self.block[i][5] == 1 then
			if (self.block[i][1] + self.block[i][2]) == 0 or
			(self.block[i][3] + self.block[i][4]) == 0 then
				self.block[i][5] = 2  
			end
		end
	end

	
	local has_moves = check_available_moves(self) == 1

	
	for i = 1, 28 do
		self.block[i][5] = temp_block_states[i]
	end

	if not has_moves and attempt < max_attempts then
		print("‚ùå –ü–æ–ø—ã—Ç–∫–∞ " .. attempt .. ": –Ω–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö —Ö–æ–¥–æ–≤")
		timer.delay(0.05, false, function()
			shuffle_until_available_moves(self, attempt + 1)
		end)
	else
		
		if has_moves then
			print("‚úÖ –£–°–ü–ï–•: –≤–∞–ª–∏–¥–Ω—ã–π —Ä–∞—Å–∫–ª–∞–¥ –Ω–∞–π–¥–µ–Ω –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ " .. attempt)
		else
			print("‚ùå –ù–ï–£–î–ê–ß–ê: –ø–æ—Å–ª–µ " .. attempt .. " –ø–æ–ø—ã—Ç–æ–∫ —Ö–æ–¥–æ–≤ –Ω–µ—Ç")
		end

		
		for i = 1, 28 do
			if self.block[i][5] == 1 then
				if (self.block[i][1] + self.block[i][2]) == 0 or
				(self.block[i][3] + self.block[i][4]) == 0 then
					self.block[i][5] = 2
				end
			end
		end
		for i = 1, 28 do
			if self.block[i][5] ~= 0 then
				
				if self.block[i][5] == 2 then
					msg.post(self.id[i], "set_flag")
					msg.post(self.id[i], "switch_to_sprite1")
				else
					msg.post(self.id[i], "reset_flag")
					msg.post(self.id[i], "switch_to_sprite2")
				end
			end
		end
		self.animation_allowed = true
		for i = 1, 28 do
			local bon = self.run_col[i][1]
			local xx = self.pole[i][3]
			local yy = self.pole[i][4]
			local tt = self.pole[i][5]
			local zz = self.pole[i][6]
			create_bone(self, i, bon, xx, yy, tt, zz)
		end
		start_animations(self)

		
		timer.delay(2.0, false, function()
			local final_check = check_available_moves(self)
			if final_check == 0 then
				print("‚ùå –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É '–ù–µ—Ç —Ö–æ–¥–∞'")
				go.animate("button_rundom", "position", go.PLAYBACK_ONCE_FORWARD, 
				vmath.vector3(0, -2000, 0), go.EASING_OUTBOUNCE, 0.8)
				go.set_position(vmath.vector3(0, -2000, 0), "button_rundom#collisionobject")
			end
		end)
	end
end
function set_button(self,n)
	msg.post("score", "update_score", {score = self.score})
	msg.post("score_global", "update_score", {score = self.score_global})
	go.set_position(vmath.vector3(10000, -10000, 0), "dot")
	go.set_position(vmath.vector3(self.button[1][n][1], self.button[1][n][2], 0), "button_nastr")
	go.set_position(vmath.vector3(self.button[1][n][1], self.button[1][n][2], 0), "button_nastr#collisionobject")
	go.set_position(vmath.vector3(self.button[2][n][1], self.button[2][n][2], 0), "button_help")
	go.set_position(vmath.vector3(self.button[2][n][1], self.button[2][n][2], 0), "button_help#collisionobject")
	go.set_position(vmath.vector3(self.button[3][n][1], self.button[3][n][2], 0), "button_range")
	go.set_position(vmath.vector3(self.button[3][n][1], self.button[3][n][2], 0), "button_range#collisionobject")
	go.set_position(vmath.vector3(self.button[4][n][1], self.button[4][n][2], 0), "button_piramid")
	go.set_position(vmath.vector3(self.button[4][n][1], self.button[4][n][2], 0), "button_piramid#collisionobject")
	go.set_position(vmath.vector3(self.button[5][n][1], self.button[5][n][2], 0), "button_pismo")
	go.set_position(vmath.vector3(self.button[5][n][1], self.button[5][n][2], 0), "button_pismo#collisionobject")
	go.set_position(vmath.vector3(self.button[6][n][1], self.button[6][n][2], 0), "button_stena")
	go.set_position(vmath.vector3(self.button[6][n][1], self.button[6][n][2], 0), "button_stena#collisionobject")
	go.set_position(vmath.vector3(self.button[7][n][1], self.button[7][n][2], 0), "button_krest")
	go.set_position(vmath.vector3(self.button[7][n][1], self.button[7][n][2], 0), "button_krest#collisionobject")
	go.set_position(vmath.vector3(self.button[8][n][1], self.button[8][n][2], 0), "button_solnce")
	go.set_position(vmath.vector3(self.button[8][n][1], self.button[8][n][2], 0), "button_solnce#collisionobject")
	go.set_position(vmath.vector3(self.button[9][n][1], self.button[9][n][2], 0), "button_change")
	go.set_position(vmath.vector3(self.button[9][n][1], self.button[9][n][2], 0), "button_change#collisionobject")
	go.set_position(vmath.vector3(self.button[10][n][1], self.button[10][n][2], 0), "button_exite")
	go.set_position(vmath.vector3(self.button[10][n][1], self.button[10][n][2], 0), "button_exite#collisionobject")
	go.set_position(vmath.vector3(self.button[11][n][1], self.button[11][n][2], 0), "button_rundom")
	go.set_position(vmath.vector3(self.button[11][n][1], self.button[11][n][2], 0), "button_rundom#collisionobject")
	go.set_position(vmath.vector3(self.button[12][n][1], self.button[12][n][2], 0), "button_oko")
	go.set_position(vmath.vector3(self.button[12][n][1], self.button[12][n][2], 0), "button_oko#collisionobject")
	go.set_position(vmath.vector3(self.button[13][n][1], self.button[13][n][2], 0), "button_menu")
	go.set_position(vmath.vector3(self.button[13][n][1], self.button[13][n][2], 0), "button_menu#collisionobject")
	go.set_position(vmath.vector3(self.button[14][n][1], self.button[14][n][2], 0), "button_povtor")
	go.set_position(vmath.vector3(self.button[14][n][1], self.button[14][n][2], 0), "button_povtor#collisionobject")
	
	
	
	go.set_position(vmath.vector3(self.button[15][n][1], self.button[15][n][2], 0), "button_restart")
	go.set_position(vmath.vector3(self.button[15][n][1], self.button[15][n][2], 0), "button_restart#collisionobject")
	go.set_position(vmath.vector3(self.button[16][n][1], self.button[16][n][2], 0), "icone_no_exite")
	go.set_position(vmath.vector3(self.button[17][n][1], self.button[17][n][2], 0), "button_yes")
	go.set_position(vmath.vector3(self.button[17][n][1], self.button[17][n][2], 0), "button_yes#collisionobject")
	go.set_position(vmath.vector3(self.button[18][n][1], self.button[18][n][2], 0), "button_no")
	go.set_position(vmath.vector3(self.button[18][n][1], self.button[18][n][2], 0), "button_no#collisionobject")
	go.set_position(vmath.vector3(self.button[19][n][1], self.button[19][n][2], 0), "button_reklama_oko")
	go.set_position(vmath.vector3(self.button[19][n][1], self.button[19][n][2], 0), "button_reklama_oko#collisionobject")
	go.set_position(vmath.vector3(self.button[20][n][1], self.button[20][n][2], 0), "button_reklama_rel")
	go.set_position(vmath.vector3(self.button[20][n][1], self.button[20][n][2], 0), "button_reklama_rel#collisionobject")
	go.set_position(vmath.vector3(self.button[21][n][1], self.button[21][n][2], 0), "score")
	go.set_position(vmath.vector3(self.button[22][n][1], self.button[22][n][2], 0), "score_global")
end
function set_ramka(self,n)
	for i = 1, 28 do
		local xx = self.ramka[i][n][1]
		local yy = self.ramka[i][n][2]
		local tt = self.ramka[i][n][3]
		local zz = 0
		create_ramka(self, i, xx, yy, tt, zz)
	end
end
function create_ramka(self, i, xx, yy, tt, zz)
	local ramka_id = self.ramka_ids[i]
	
	msg.post(ramka_id, "enable")
	go.set_position(vmath.vector3(xx, yy, zz), ramka_id)
	go.set_rotation(vmath.quat_rotation_z(tt), ramka_id)

	
	go.animate(ramka_id, "position", go.PLAYBACK_ONCE_FORWARD, 
	vmath.vector3(xx, yy, zz), go.EASING_OUTBOUNCE, 0.5)
	go.animate(ramka_id, "euler.z", go.PLAYBACK_ONCE_FORWARD, 
	tt, go.EASING_OUTBACK, 0.5)
end

function init_level(self)
	
	self.run_col = {}
	self.f_reload = 3
	self.hod = 1
	button_rundom_set(self)
	for i = 1, #self.koloda do
		self.run_col[i] = self.koloda[i]
	end
	
	for i = #self.run_col, 2, -1 do
		local j = math.random(1, i)
		self.run_col[i], self.run_col[j] = self.run_col[j], self.run_col[i]
	end
	for  i = 1, 28 do
		self.block[i]={}
		for j =1, 4 do
			self.block[i][j]=self.level[self.lev][i][j+6]
		end
		self.pole[i]={}
		for j=1, 10 do
			self.pole[i][j] = self.level[self.lev][i][j]
		end
		self.block[i][5]=1
	end

	
	local has_valid_moves = false
	local check_attempts = 0
	local max_check_attempts = 5

	while not has_valid_moves and check_attempts < max_check_attempts do
		check_attempts = check_attempts + 1

		
		for i = 1, 28 do
			if self.block[i][5] == 1 then
				if (self.block[i][1] + self.block[i][2]) == 0 or
				(self.block[i][3] + self.block[i][4]) == 0 then
					self.block[i][5] = 2
				end
			end
		end

		
		has_valid_moves = check_available_moves(self) == 1

		
		if not has_valid_moves then
			print("‚ùå –ü–æ–ø—ã—Ç–∫–∞ " .. check_attempts .. ": –Ω–∞—á–∞–ª—å–Ω—ã–π —Ä–∞—Å–∫–ª–∞–¥ –±–µ–∑ —Ö–æ–¥–æ–≤ - –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º")

			
			local active_indices = {}
			local active_rows = {}
			for i = 1, 28 do
				if self.block[i][5] ~= 0 then
					table.insert(active_indices, i)
					table.insert(active_rows, self.run_col[i])
				end
			end

			for i = #active_rows, 2, -1 do
				local j = math.random(1, i)
				active_rows[i], active_rows[j] = active_rows[j], active_rows[i]
			end

			for idx, original_index in ipairs(active_indices) do
				self.run_col[original_index] = active_rows[idx]
			end

			
			for i = 1, 28 do
				self.block[i][5] = 1
			end
		end
	end

	
	for i = 1, 28 do
		if self.block[i][5] == 1 then
			if (self.block[i][1] + self.block[i][2]) == 0 or
			(self.block[i][3] + self.block[i][4]) == 0 then
				self.block[i][5] = 2
			end
		end
	end
	bone_shared.sprite2_alpha = 1
	for i = 1, 28 do
		msg.post(self.id[i], "update_alpha_only")
	end







	
	msg.post("button_oko", "set_image", {image_number = self.f_oko})
	msg.post("button_reklama_oko", "set_image", {image_number = self.rek_but_oko})
	msg.post("button_reklama_rel", "set_image", {image_number = self.rek_but_rel})
	
	self.animation_allowed = true
	for i = 1, 28 do
		create_bone(self, i, self.run_col[i][1], self.pole[i][3], self.pole[i][4],self.pole[i][5], self.pole[i][6])
	end
	start_animations(self)
	for i = 1, 28 do
		
		if self.block[i][5] == 2 then
			msg.post(self.id[i], "set_flag")
			msg.post(self.id[i], "switch_to_sprite1")
		else
			msg.post(self.id[i], "reset_flag")
			msg.post(self.id[i], "switch_to_sprite2")
		end
	end

	
	if not has_valid_moves then
		print("‚ùå –í–°–ï –ü–û–ü–´–¢–ö–ò –ò–°–ß–ï–†–ü–ê–ù–´: –Ω–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö —Ö–æ–¥–æ–≤")
		timer.delay(2.0, false, function()
			go.animate("button_rundom", "position", go.PLAYBACK_ONCE_FORWARD, 
			vmath.vector3(0, -2000, 0), go.EASING_OUTBOUNCE, 0.8)
			go.set_position(vmath.vector3(0, -2000, 0), "button_rundom#collisionobject")
		end)
	else
		print("‚úÖ –ù–∞—á–∞–ª—å–Ω—ã–π —Ä–∞—Å–∫–ª–∞–¥ –ø—Ä–æ–≤–µ—Ä–µ–Ω: –µ—Å—Ç—å –≤–∞–ª–∏–¥–Ω—ã–µ —Ö–æ–¥—ã")
	end
	
end
local function screen_to_world(x, y, z, camera_id)
	local projection = camera.get_projection(camera_id)
	local view = camera.get_view(camera_id)
	local w, h = window.get_size()
	local inv = vmath.inv(projection * view)
	x = (2 * x / w) - 1
	y = (2 * y / h) - 1
	z = (2 * z) - 1
	local x1 = x * inv.m00 + y * inv.m01 + z * inv.m02 + inv.m03
	local y1 = x * inv.m10 + y * inv.m11 + z * inv.m12 + inv.m13
	local z1 = x * inv.m20 + y * inv.m21 + z * inv.m22 + inv.m23
	return x1, y1, z1
end
function simple_auto_zoom(self)
	
	local left = -2800
	local right = 2800
	local bottom = -2800
	local top = 2800

	
	local field_width = right - left
	local field_height = top - bottom

	
	local screen_w, screen_h = window.get_size()

	
	local zoom_x = screen_w / field_width
	local zoom_y = screen_h / field_height
	local zoom = math.min(zoom_x, zoom_y) * 0.9  

	
	go.set("/pole#camera", "orthographic_zoom", zoom)
	

	print(string.format("–ó—É–º: %.3f (—ç–∫—Ä–∞–Ω %dx%d)", zoom, screen_w, screen_h))
end




function init(self)
	self.last_width = 0
	self.last_height = 0
	
	
	math.randomseed(os.time())
	msg.post(".", "acquire_input_focus")
	self.active_timers = {}
	self.animation_allowed = true
	self.pending_animations = {}
	self.id = {{},{},{},{}}
	self.ramka_ids = {}
	self.block = {}
	self.v1=0
	self.v2=0
	self.vv=0
	self.lev=2
	self.score = 0
	self.score_global = 0
	
	
	self.rek_but_oko = 0
	self.rek_but_rel = 0
	self.f_vid_rek = false
	self.game_started = false
	local lua_mod = require("main.lua")
	self.ramka = lua_mod.get_ram()
	self.koloda = lua_mod.get_kol()
	self.level = lua_mod.get_l()
	self.button = lua_mod.get_but()
	self.pole = {}
	self.f_oko = 9
	self.b_oko = false
	
	set_button(self, 1)
	for i = 1, 28 do
		self.ramka_ids[i] = factory.create("#ramka_factory", vmath.vector3(0, -5000, 0))
	end
	for i = 1, 24 do
		self.id[i] = factory.create("/pole#bone_factory", vmath.vector3(0, -5000, 0))
	end
	for i = 25, 28 do
		self.id[i] = factory.create("/pole#bone_up_factory", vmath.vector3(0, -5000, 0))
	end
	simple_auto_zoom(self)

	
	msg.post(".", "acquire_input_focus")
end

                    
	
   

function update(self, dt)
	
	self.check_timer = (self.check_timer or 0) + dt
	if self.check_timer > 0.5 then
		self.check_timer = 0

		local w, h = window.get_size()
		if w > 0 and h > 0 and (w ~= self.last_width or h ~= self.last_height) then
			print("–†–∞–∑–º–µ—Ä –∏–∑–º–µ–Ω–∏–ª—Å—è: " .. w .. "x" .. h)
			self.last_width = w
			self.last_height = h
			simple_auto_zoom(self)
		end
	end
	
end

                               
	
   

function on_message(self, message_id, message, sender)
	
	if message_id == hash("window_resized") then
		simple_auto_zoom(self)  
	end
	if message_id == hash("bone_clicked") then
		self.vv = message.bone_number

		
		if self.block[self.vv][5] ~= 2 then
			return  
		end

		if self.v1 == 0 then
			self.v1 = self.vv
			msg.post(self.id[self.vv], "spin_15")
		else
			if self.v1 == self.vv then
				
				self.v1 = 0
				msg.post(self.id[self.vv], "spin_15")
			else
				
				self.v2 = self.v1
				self.v1 = self.vv
				msg.post(self.id[self.vv], "spin_15")
			end
		end

		
		if self.v1 ~= 0 and self.v2 ~= 0 and self.v1 ~= self.v2 then
			self.summ = self.run_col[self.v1][2] + self.run_col[self.v2][2]
			if self.summ == 12 then
				self.delta_score=math.abs(self.run_col[self.v1][2] - self.run_col[self.v2][2]) * self.hod * self.f_reload
				self.score = self.score + self.delta_score
				msg.post("score", "update_score", {score = self.score})
				self.hod = self.hod+1
				
				go.animate(self.id[self.v1], "position", go.PLAYBACK_ONCE_FORWARD, 
				vmath.vector3(0, -5000, 0), go.EASING_OUTBOUNCE, 0.8)
				self.block[self.v1][5] = 0
				go.animate(self.id[self.v2], "position", go.PLAYBACK_ONCE_FORWARD, 
				vmath.vector3(0, -5000, 0), go.EASING_OUTBOUNCE, 0.8)
				self.block[self.v2][5] = 0

				
				for i = 1, 28 do
					for j = 1, 4 do
						if self.block[i][j] == self.v1 or self.block[i][j] == self.v2 then
							self.block[i][j] = 0
							print("clear ", self.v1, " / ", self.v2)
						end
					end
				end

				
				for i = 1, 28 do
					if self.block[i][5] == 1 then
						if (self.block[i][1] + self.block[i][2]) == 0 or
						(self.block[i][3] + self.block[i][4]) == 0 then
							self.block[i][5] = 2
							msg.post(self.id[i], "set_flag")
							msg.post(self.id[i], "switch_to_sprite1")
						end
					end
				end
			else
				
				resp(self)
			end
			
			
			self.v1 = 0
			self.v2 = 0
			
			
			local all_cleared = true
			for i = 1, 28 do
				if self.block[i][5] ~= 0 then
					all_cleared = false
					break
				end
			end

			if all_cleared then
				msg.post("score", "update_score", {score = self.score})
				self.score_global = self.score_global + self.score
				msg.post("score_global", "update_score", {score = self.score_global})
				self.score=0
				set_button(self, 4)
				set_ramka(self, 4)
			end
		end

		
		self.sf = check_available_moves(self)
		if self.sf == 0 then
			print("–ù–ï–¢ –•–û–î–ê !!! ========================")
		end
	end
	
	if message_id == hash("button_return_clicked") then
		if self.f_reload == 0 then
			if self.rek_but_rel == 0 then
				self.sf = check_available_moves(self)
				if self.sf == 0 then
					self.score=0
					msg.post("score", "update_score", {score = self.score})
					set_button(self, 4)
					set_ramka(self, 5)
					ubrat_all_bones(self)
					return
				else
					
					return
				end
			else
				self.rek_but_rel = self.rek_but_rel - 1
				msg.post("button_reklama_rel", "set_image", {image_number = self.rek_but_rel})
				button_rundom_set(self)
				bone_shared.sprite2_alpha = 1
				for i = 1, 28 do
					msg.post(self.id[i], "update_alpha_only")
				end
			end
		else
			self.f_reload = self.f_reload-1
			button_rundom_set(self)
			bone_shared.sprite2_alpha = 1
			for i = 1, 28 do
				msg.post(self.id[i], "update_alpha_only")
			end
		end
		
		if self.v1 ~= 0 then
			msg.post(self.id[self.v1], "spin_15")
			self.v1 = 0
		end
		if self.v2 ~= 0 then
			msg.post(self.id[self.v2], "spin_15")
			self.v2 = 0
		end
		
		local had_moves = check_available_moves(self) == 1

		
		if had_moves then
			self.score = self.score - 500  
			
		end
		if self.score < 0 then
			self.score = 0
		end
		msg.post("score", "update_score", {score = self.score})
		ubrat_all_bones(self)

		
		timer.delay(0.8, false, function()
			shuffle_until_available_moves(self, 1)
		end)
	end


	
	
	if message_id == hash("button_piramid_clicked") then
		set_button(self, 2)
		self.lev=1
		msg.post("button_povtor", "set_image", {image_number = 1})
		init_level(self)
	end
	if message_id == hash("button_pismo_clicked") then
		set_button(self, 2)
		self.lev=2
		msg.post("button_povtor", "set_image", {image_number = 2})
		init_level(self)
	end
	if message_id == hash("button_stena_clicked") then
		set_button(self, 2)
		self.lev=3
		msg.post("button_povtor", "set_image", {image_number = 3})
		init_level(self)
	end
	if message_id == hash("button_krest_clicked") then
		set_button(self, 2)
		self.lev=5
		msg.post("button_povtor", "set_image", {image_number = 5})
		init_level(self)
	end
	if message_id == hash("button_solnce_clicked") then
		set_button(self, 2)
		self.lev=4
		msg.post("button_povtor", "set_image", {image_number = 4})
		init_level(self)
	end
	


	
	
	if message_id == hash("button_exite_clicked") then
		print("message_id == hash(button_exite_clicked)")
		stop_animations(self)
		set_button(self, 3)
		set_ramka(self, 3)
	end
	if message_id == hash("button_yes_clicked") then
		ubrat_all_bones(self)
		set_button(self, 1)
		set_ramka(self, 1)
	end
	if message_id == hash("button_menu_clicked") then
		for i=1, 28 do
			if self.id[i] then
				
				go.animate(self.id[i], "position", go.PLAYBACK_ONCE_FORWARD,vmath.vector3(0, -5000, 0), go.EASING_OUTBOUNCE, 0.5)
			end
		end
		set_button(self, 1)
		set_ramka(self, 1)
	end
	if message_id == hash("button_povtor_clicked") then
		set_button(self, 2)
		init_level(self)
		set_ramka(self, 1)
	end
	if message_id == hash("button_change_clicked") then
		set_button(self, 5)
		set_ramka(self, 5)
	end
	if message_id == hash("button_oko_clicked") then
		if self.f_oko > 0 and bone_shared.sprite2_alpha==1 then
			self.f_oko = self.f_oko - 1
			self.b_oko = true
			msg.post("button_oko", "set_image", {image_number = self.f_oko})
			bone_shared.sprite2_alpha = 0.4
			for i = 1, 28 do
				msg.post(self.id[i], "update_alpha_only")
			end
		end
		if self.f_oko == 0 then
			if self.rek_but_oko > 0 then
				self.f_oko = self.rek_but_oko
				self.rek_but_oko =0
				msg.post("button_oko", "set_image", {image_number = self.f_oko})
				msg.post("button_reklama_oko", "set_image", {image_number = self.rek_but_oko})
			end
		end
	end
	if message_id == hash("button_no_clicked") then
		set_button(self, 2)
		set_ramka(self, 1)
		ubrat_all_bones(self)
		for i = 1, 28 do
			if self.block[i][5] ~= 0 then
				
				if self.block[i][5] == 2 then
					msg.post(self.id[i], "set_flag")
					msg.post(self.id[i], "switch_to_sprite1")
				else
					msg.post(self.id[i], "reset_flag")
					msg.post(self.id[i], "switch_to_sprite2")
				end
			end
		end
		self.animation_allowed = true
		for i = 1, 28 do
			create_bone(self, i, self.run_col[i][1], self.pole[i][3], self.pole[i][4], self.pole[i][5], self.pole[i][6])
		end
		start_animations(self)
	end
	if message_id == hash("button_reklama_oko_clicked") then
		print("button_reklama_oko_clicked")
		if self.rek_but_oko < 9 then
			self.f_vid_rek = false
			video_reklama(self)
			if self.f_vid_rek then
				self.rek_but_oko = self.rek_but_oko+1
				msg.post("button_reklama_oko", "set_image", {image_number = self.rek_but_oko})
				
			end
		end
	end
	if message_id == hash("button_reklama_rel_clicked") then
		print("button_reklama_rel_clicked")
		if self.rek_but_oko < 9 then
			self.f_vid_rek = false
			video_reklama(self)
			if self.f_vid_rek then
				self.rek_but_rel = self.rek_but_rel+1
				msg.post("button_reklama_rel", "set_image", {image_number = self.rek_but_rel})
				button_rundom_set(self)

			end
		end

	end
end



function on_input(self, action_id, action)
	if action.pressed then
		local worldx, worldy = screen_to_world(action.screen_x, action.screen_y, 0, "/pole#camera")
		local world = vmath.vector3(worldx, worldy, 0)

		go.set_position(vmath.vector3(10000, -10000, 0), "dot")
		timer.delay(0.1, false, function()
			go.set_position(world, "dot")
		end)
		
	end
end

                        
	
   
@main/pole.scriptmain.bone_sharedmain.lua/main/bone_shared.luac/main/lua.luac" 